# 小程序

### 数据劫持代理-响应式数据原理

在浏览器console.log出来的对象中有(...)这样的就是数据劫持代理

![image-20230808100126755](C:\Users\asus\OneDrive\桌面\笔记\images\image-20230808100126755.png)

数据劫持：当点击 ( ... ) 时，this实例就会调用get()劫持data的数据，

**当想要修改某个属性如username时，（_this.username = 'wade'）就会调用set操作，获取newValue(wade)直接更改data中的数据，从而实现数据的双向绑定**

```js
//vue数据劫持代理
//模拟vue中data选项
let data = {
	username: 'curry',
	age: 33
}

//模拟组件实例
let _this ={

}

//利用Object.defineProperty()
for(let item in data){
    Object.defineProperty(_this, item, {
        //get：用来获取扩展属性值的，当获取该属性值时就调用
        get(){
			console.log('get()')
            return data[item]
        },
        //set：监视扩展属性，只要修改就调用
        set(newValue){
			console.log('set()',newValue)
            //_this.username = newValue X 千万不能在set方法中直接修改当前扩展属性的值，会死循环
            data[item] = newValue
        }
    })
}

console.log(_this);
//通过Object.defineProperty的get方法添加的扩展属性不能使用‘对象.属性’来修改
_this.username = 'wade'

```



---





### 路由跳转

微信开放文档-API-路由

tabbar功能如下：

顶部：

![image-20230808113723096](C:\Users\asus\OneDrive\桌面\笔记\images\image-20230808113723096.png)

底部：

![image-20230808113736563](C:\Users\asus\OneDrive\桌面\笔记\images\image-20230808113736563.png)

##### 1.wx.navigateTo({url:''})

保留当前页面，跳转到应用内的某个页面，但是不允许跳转到tabbar页面，左上角小箭头(wx.navigateBack)返回

##### 2.wx.redirectTO({url:''})

关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到tabbar页面，左上角小房子回到首页

##### 3.wx.reLaunch({url:''})

关闭所有页面，打开到应用内的某个页面



##### 点击跳转

```html
<navigator :url="路径"></navigator>
```



---





### 小程序分包

分包的含义：把tabBar有关的页面放到主包中，其他页面放到分包中，

分包的目的：可以减少小程序首次启动时的加载时间，优化性能

分包步骤：在page.json中和page节点评级的位置声明subPackages节点，用来定义分包相关的结构

```json
"subPackages":[

​	{
    	"root":"subpkg", 	//分包名
    	"pages":[]			//分包页面
    }

]
```



---





### 生命周期函数 5个

微信开放文档-指南-小程序框架-页面生命周期

按照时间顺序

##### onLoad: function (options) {}

监听页面加载，只执行一次，此时没有页面基本结构数据



##### onShow: function (options) {}

监听页面显示，可与onHide配合多次执行，



##### onReady: function (options) {}

监听页面初次渲染完成，只执行一次，



##### onHide: function (options) {}

监听页面隐藏，可执行多次，隐藏的页面不会被销毁



##### onUnload: function (options) {}

监听页面销毁



---





### 通过api获取数据步骤(示例)

1. 新建空的data数组，用于存放请求的数据 如

   ```js
   data(){
   	return{
           floorList:[],
       }
   }
   ```

2. 在onload生命周期函数内调用请求方法，因为是展示用的静态数据，所以在onload里面请求一次便可

```js
onLoad(){
	this.getFloorList()
}
```

3.在methods里面根据api路径和请求方法写方法，解构赋值给res，

```js
methods:{
    async getFloorList(){
		const { data:res } = await uni.$http.get('/api/public/v1/home/floordata')
        if(res.meta.status !== 200) return uni.$showMsg()//如果请求失败则打印失败信息
        this.floorList = res message//请求成功就把res里面的信息放到floorList中
    }
}
```



---





#### 获取用户手机显示信息

```js
onload(){//在开始加载时获取设备信息
	const sysInfo = uni.getSystemInfoSync()    
}
```



---





#### 动态绑定样式+点击激活

```html
<view :class="['样式名',i === active ? 'active' : '']" @click="activeChanged(i)"></view>
						三元表达式决定是否给该标签赋值			绑定点击事件，传入当前i值
```

```js
methods:{
    activeChanged(i){
        this.active = i //把当前传入的i值赋值给active，active在data中初始化为1
    }
}
```



---





### 组件的使用

##### 组件的创建

1. 在项目包内新增components文件夹
2. 右键文件夹新建组件，选择使用scss组件，勾选创建同名目录

<img src="C:\Users\asus\OneDrive\桌面\笔记\images\image-20230816104219009.png" alt="image-20230816104219009" style="zoom: 50%;" />

3.然后直接使用，不需注册



###### 创建的时候路径会写到pages.json文件中



---



##### 通过自定义属性增强组件的通用性

以下两者都是在组件文件内

组件内给定props的传递参数（带默认值）

```js
props:{
	//背景颜色
    bgcolor:{
        type:String,
        default:'#C00000'
    },
    //圆角
    radius:{
        type:Number,
        default:18
    }
}
```

html内动态绑定样式

```html
<view class="xxx" :style="{'background-color':bgcolor}">
	<view class="xxx" :style="{'border-radius':radius + 'px'}"></view>
</view>
	
```



在引用组件的地方

```html
<组件 :bgcolor="'black'"></组件>
```



---



##### 组件的点击事件

在引用组件的地方不能直接绑定点击事件触发，**而是要在组件内部绑定一个点击事件，并通过$emit传值给父组件**

```html
引用组件的地方
<组件 @click="gotoSearch"></组件>
```



在组件处

```html
<template>
	<view @click="searchBoxHandler"></view>
</template>
```

```js
methods:{
    searchBoxHandler(){
        this.$emit('click')//引用组件的地方绑定点击的名字
    }
}
```



---



#### 抽取封装组件

components里面新建组件(my-goods)

封装组件

```vue
<template>
	<view>
    	<image :src="goods.goods_small_logo || default"></image>
    </view>
</template>
<script>
export default{
    props:{//接收父组件引用时传入的参数  <!--*-->号所在的地方
        goods:{
			type:Object,
            default:{},
        }
    },
}
</script>
<style>
	//样式
</style>
```

引用组件

```vue
<template>         
	<block v-for="(goods,i) in goodsList" :key="i">
        			<!--*-->
		<my-goods :goods="goods"></my-goods>  //这里动态绑定goods对象给组件传值
	</block>
</template>
<script>
export default{
    data(){
        return{
            queryObj:{
                query: '',
                cid: '',
                pagenum: 1,
                pagesize: 10,
            }
        }
    },
    goodList:[],
}
</script>

```





---



#### 点击事件获取焦点（弹出键盘）

在组件源代码data里面修改show和showSync的值

```js
data(){
    return{
        show: true,
        showSync: true,
    }
}
```



---



### 搜索功能的实现

##### 实现搜索框的防抖处理

1.在data中定义防抖的掩饰其timerId如下

```js
data(){
    return{
        timer:null,
        kw:''
    }
}
```

2.修改input事件处理函数如下

```js
input(e){
    //检测到输入之后就清除timer对应的延时器，取消发送请求，当输入完毕后延时器经过500毫秒才发送请求
    clearTimeout(this.timer)
    //重新启动延时器
    this.timer = setTimeout(() => {
        this.kw=e.value
        console.log(this.kw)//可以改成发送请求
    },500)
}
```



##### 实现搜索功能（api请求）

1.data中定义新的searchResult数组存储返回结果

```js
data(){
    return{
        timer:null,
        kw:'',
        searchResults:[],
    }
}
```

2.在防抖函数中新增请求方法

```js
input(e){
    //检测到输入之后就清除timer对应的延时器，取消发送请求，当输入完毕后延时器经过500毫秒才发送请求
    clearTimeout(this.timer)
    //重新启动延时器
    this.timer = setTimeout(() => {
        this.kw=e.value
		getSearchList()
    },500)
}
```

3.新增请求函数

```js
async getSearchList(){
    if(this.kw === ''){
        this.searchResults = []
        return
    }
    //	 解构赋值给res		$http是自己封装的请求方法，这次query参数，下面的$showMsg也是
   	const {data: res} = await uni.$http.get('请求路径',{ query: this.kw })
    if(res.meta.status !== 200) return uni.$showMsg()
    this.searchResults = res.message
}
```





##### 数据(历史记录)持久化到本地

```js
saveSearchHistory(){
    ...
    uni.setStorageSync('数据名',JSON.stringify(this.historyList))//把数据转化成字符串
}
```

加载本地存储的的数据

```js
onload(){
    this.historyList = JSON.parse(uni.getStorageSync('kw') || '[]')
}
```





#### 实现上拉加载更多页面

1.在根目录下的pages.json文件中,为subPackages分包中的goods_list页面中的**style**配置上拉触底的距离

```json
"subPackages": [
    {
        "root": "subpkg",
        "pages": [
            ..
            {
            	"path": "goods_list/goods_list",
            	"style": {
					"onReachBottomDistance": 150            	
            	}
            }
        ]
    }
]
```

2.在goods_list页面中,和methods节点平级,声明onReachBottom事件处理函数

```js
onReachBottom(){
    //让页码值自增
    this.queryObj.pagenum += 1
    //重新获取列表数据
    this.getGoodList()
}
```

3.在methods中的getGoodsList函数中对新旧数据进行**拼接**

```js
async getGoodsList(){
    if(this.kw === ''){
        this.searchResults = []
        return
    }
    //	 解构赋值给res		$http是自己封装的请求方法，这次query参数，下面的$showMsg也是
   	const {data: res} = await uni.$http.get('请求路径',{ query: this.queryObj})
    if(res.meta.status !== 200) return uni.$showMsg()
    
    //为数据赋值,通过拓展运算符将新旧数据展开后合并
    this.goodsList = [...this.goodsList, ...res.message.goods]
    this.total = res.mesage.total
}
```





### 手写节流阀

1.data中定义一个isloading,默认值为false

```js
data(){
    return{
        isloading: false
    }
}
```

2.在请求前后加上节流阀的打开和关闭

```js
async getGoodsList(){
	//打开节流阀
    this.isloading = true
    //发起请求
   	const {data: res} = await uni.$http.get('请求路径',{ query: this.queryObj})
	//关闭节流阀
    this.isloading = false
}
```

3.在触底请求数据的函数中,根据节流阀判断来决定是否发起请求

```js
onReachBottom(){
    if(this.isloading) return //当节流阀为打开状态时直接返回,不进行数据请求 
    //让页码值自增
    this.queryObj.pagenum += 1
    //重新获取列表数据
    this.getGoodList()
}
```





#### 下拉刷新

和下拉刷新差不多,也需要在page.json配置文件中做修改

1.在page.json中,为当前的goods_list页面单独开启下拉刷新效果

```json
"subPackages": [
    {
        "root": "subpkg",
        "pages": [
            ..
            {
            	"path": "goods_list/goods_list",
            	"style": {
					"onReachBottomDistance": 150,
            		"enablePullDownRefresh": true,
            		"backgroundColor": "#F8F8F8",
            	}
            }
        ]
    }
]
```

2.在监听页面新增onPullDownRefresh事件处理函数中

发起请求的同时要传递关闭下拉刷新的参数,否则不会停止下拉刷新

```js
onPullDownRefresh(){
    //重置关键数据
    this.queryObj.pagenum = 1
    this.total = 0
    this.isloading = false
    this.goodsList = []
    
    //重新发起请求
    this.getGoodsList(() => uni.stopPullDownRefresh())//请求的同时携带参数,关闭下拉刷新
}
```

3.修改getGoodsList函数,接收cb回调函数并进行调用--**短路运算实现逻辑判断**

```js
//注意这里传递了一个参数↓
async getGoodsList(cb){
	//打开节流阀
    this.isloading = true
    //发起请求
   	const {data: res} = await uni.$http.get('请求路径',{ query: this.queryObj})
	//关闭节流阀
    this.isloading = false
    
    //短路运算,如果有参数传递进来就执行cb()关闭下拉刷新,参数来源于onPullDownRefresh()的重新发起请求
    //如果没有则不成真,不调用参数中的方法
    cb && cb()
    ...
}
```







#### 轮播图预览效果

1.为image图片绑定click处理函数

```html
<swiper-item v-for="(item, i) in goods_info.pics" :key="i">
	<!--把当前图片的索引i传递到preview()处理函数中-->
    <iamge :src="item.pics_big" @click="preview(i)"></iamge>
</swiper-item>	
```

2.在methods中定义preview事件处理函数

```js
preview(i){
    //调用uni.previewImage()方法预览图片
    uni.previewImage({
        //预览时默认显示图片的索引
        current:i,
        //goods_info内有数组pics存放预览图片的url路径,使用map循环遍历里面的每一个item项(x),
        //然后一个个返回x.pics_big url路径生成一个数组
        urls:this.goods_info.pics.map(x => x.pics_big)
    })
}
```





#### 使用富文本的时候利用正则表达式给富文本内的元素加上样式

<img src="C:\Users\asus\OneDrive\桌面\笔记\images\image-20230817135148231.png" alt="image-20230817135148231" style="zoom:50%;" />

```html
<rich-text :node="goods_info.goods_introduce"></rich-text>
```

```js
										//全局
res.message.goods_introduce.replace(/<img /g, '<img style="display:block;" ').replace(..)
								  //要替换的	//替换成
```





##### 根据id删除对应的商品

##### filter()函数的应用

```js
mutations内
removeGoodsById(state,goods_id){
    state.cart = state.cart.filter(x => x.goods.id !== goods_id)
}
```

代码`state.cart = state.cart.filter(x => x.goods_id !== goods.id)`的作用是从`state.cart`数组中筛选出所有`goods_id`不等于`goods.id`的元素，并将结果重新赋值给`state.cart`变量。

这段代码使用了`filter()`方法来过滤数组。`filter()`方法接受一个回调函数作为参数，并遍历数组的每个元素。回调函数的逻辑是，只返回`goods_id`不等于`goods.id`的元素。最终，`filter()`方法返回满足条件的元素组成的新数组。

旧的`state.cart`数组被覆盖，新的、只包含满足条件的元素的数组将成为`state.cart`的值。这就意味着，通过这段代码，从购物车中移除了`goods_id`等于`goods.id`的商品。



#### 组件通信-子传父

此页面为购物车cart.vue页面，下面每个物品即为封装的my-goods组件

现在要实现点击数字框**改变商品数量**的需求

<img src="C:\Users\asus\OneDrive\桌面\笔记\images\image-20230827165429884.png" alt="image-20230827165429884" style="zoom:50%;" />

1.在cart.vue组件内部封装num-change事件，这个事件用来获取当前商品的goods_id和goods_count;

```vue
这里是cart.vue
<block v-for="(goods,i) in cart" :key="i">
	<my-goods :goods="goods" @num-change="numberChangeHandler"></my-goods>
</block>
...

methods:{
	numberChangeHandler(e){

	}
}
```

 2.在my-goods.vue组件中为数字框uni-number-box添加事件处理函数

```vue
这里是my-goods.vue
<uni-number-box @change="numChangeHandler"></uni-number-box>
...
methods:{
	numberChangeHandler(val){
		this.$emit('num-change',{//emit是往外界传值，传下面两个值
			goods_id:this.goods.goods_id,//这是props传过来的值
			goods_count: +val // +是隐式转换成数字类型
		})
	}
}
```



#### 新建一个vuex仓库 （user.js，用来存放用户信息的），并持久化

1.在store目录下面新建一个新的vuex模块——user.js

```js
export default{
    namespaced:true,
    
    //state数据，存放数据的地方
    state: ()=>({
        //address:{} jian'yi
       	address:JSON.parse(uni.getStorageSync('address')||'{}')//持久化——每次初始化都在本地读取数据
    }),
    
   	//方法，用来修改state里面的内容
    mutations:{
        updateAddress(state,address){
            state.address = address
            this.commit('m_user/saveAddressToStorage')//持久化——调用存储地址的方法
        },
        saveAddressToStorage(state){//持久化——新建存储地址的方法
            uni.setStorageSync('address', JSON.stringify(state.address))//持久化——把地址转换成字符串然后持久化
        }
    },
    //数据包装器
    getters:{
        
    }
}
```

2.在store目录的store.js中，**导入并挂载**user.js模块

```js
import Vue from 'vue'
import Vuex from 'vuex'
import moduleUser from './user.js'

//将Vuex安装作为Vue的插件
Vue.use(Vuex)

//创建Store的实例对象
const store = new Vuex.Store({
    modules:{
		//挂载模块，并重命名
        m_user:moduleUser,
    }
})

//向外暴露 
export default store
```



#### 修改购物车中商品数量-vuex持久化

1.在store/cart.js模块中，声明如下的mutations方法，用来修改对应商品的数量

```js
updateGoodsCount(state,goods){
    //根据goods_id查询购物车中对应商品的信息对象
    const findResult = state.cart.find(x => x.goods_id === goods.goods_id)
    
    if(findResult){//如果找到商品
        //更新对应商品数量
        findResult.goods_count = goods.goods_count
        //持久化存储到本地
        this.commit('m_cart/saveToStorage')
    }
}
```

2.在cart.vue页面中，通过mapMutations辅助函数将上面的方法映射到当前页面中使用

```vue
<script>
import {mapState, mapMutations} from 'vuex'
export default{
	computed:{
		...mapState('m_cart',['cart'])
	},
    methods:{
        ...mapMutations('m_cart',['updateGoodsCount']),//将方法映射到现在的页面，才在下面可以使用
        numberChangeHandler(e){//当点击事件发生时，即商品数量发生了变化，则调用updateGoodsCount
            this.updateGoodsCount(e)//传进去的e就被方法解读出来信息
        }
    }
}
</script>

```



### Hbuilder

新版Hbuilder里面新建自定义组件不能再通过components文件夹

只能在uni_modules里新建通用zu'jian

